<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>C3C – Interactive 3D Customizer</title>
<style>
*{box-sizing:border-box;margin:0;padding:0}
html,body{width:100%;height:100%;background:#e9eaee;color:#111;font-family:sans-serif}
#app{display:flex;height:100vh}
#ui{width:340px;max-width:340px;min-width:300px;padding:10px;background:#f4f5f7;overflow:auto;border-right:1px solid #dde0e6}
#canvasWrap{flex:1;position:relative;background:#e9eaee}
#c{display:block;width:100%;height:100%}
.row{margin-bottom:10px;display:flex;flex-wrap:wrap;gap:6px;align-items:center}
label{font-size:14px}
input,select,button{background:#fff;color:#111;border:1px solid #cfd6df;padding:6px;border-radius:4px}
button{cursor:pointer}
#decalGallery{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-top:6px}
#decalGallery button{background:#fff;border:1px solid #cfd6df;border-radius:6px;padding:0;overflow:hidden;height:72px}
#decalGallery img{width:100%;height:100%;object-fit:contain;background:#fff}
.note{font-size:12px;opacity:.75;color:#333}
#buildTag{position:fixed;left:8px;top:6px;opacity:.85;font:12px/1 monospace;z-index:10;color:#333}
#errorTag{position:fixed;right:8px;top:6px;background:#b00020;color:#fff;padding:6px 8px;border-radius:6px;display:none;max-width:70ch;font:12px/1.2 monospace;z-index:10}
.selectedDecal{outline:2px solid #4caf50}
</style>

<script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>
</head>
<body>
<div id="buildTag">Build r14 • initializing…</div>
<div id="errorTag"></div>

<div id="app">
  <div id="ui">
    <div class="row">
      <label for="vehicleSelect">Vehicle:</label>
      <select id="vehicleSelect"></select>
    </div>
    <div class="row">
      <label for="bodyColor">Body Color:</label>
      <input type="color" id="bodyColor" value="#1c4cff">
      <button id="applyColorBtn">Apply</button>
    </div>
    <div class="row">
      <label>Decals (click to select):</label>
      <div id="decalGallery"></div>
    </div>
    <div class="row">
      <label for="decalUpload">Upload your decal:</label>
      <input type="file" id="decalUpload" accept="image/*">
    </div>
    <div class="note">Click a decal, then click on the vehicle to place it. Drag decals to move them.</div>
  </div>
  <div id="canvasWrap"><canvas id="c"></canvas></div>
</div>

<script>
/* ===== CONFIG (YOUR LINKS) ===== */
const CONFIG = {
  vehicles: [
    { name:"Durango", url:"https://static.wixstatic.com/3d/96cc34_c0072ed49aab4a86b58e8856adc9e80d.glb" },
    { name:"Explorer", url:"https://static.wixstatic.com/3d/96cc34_3939af3ce6774519b08ad2e38484e5c4.glb" },
    { name:"Mercedes (Ambulance)", url:"https://static.wixstatic.com/3d/96cc34_0c50d7869b59405f8c57e9c69e1581c9.glb" },
    { name:"Tahoe", url:"https://static.wixstatic.com/3d/96cc34_2de4a869c4c24779a56439d7dfc02f95.glb" }
  ],
  decals: [
    "https://static.wixstatic.com/media/96cc34_45d6c4ae8e19430bb0f853a313752d6e~mv2.png",
    "https://static.wixstatic.com/media/96cc34_3b6ee3d5d22046269faa3f0abfa5be4b~mv2.png",
    "https://static.wixstatic.com/media/96cc34_02a7f12787d94a338b71cbc076c131ef~mv2.png",
    "https://static.wixstatic.com/media/96cc34_d3aae6ee15ea45b99d31d20148e73144~mv2.png",
    "https://static.wixstatic.com/media/96cc34_738b9da24fef4290b6e3ae9996a8e722~mv2.png",
    "https://static.wixstatic.com/media/96cc34_cbb180b170324ffa8803f487f2c588e3~mv2.png",
    "https://static.wixstatic.com/media/96cc34_60097843bb9a4db39d54929f138ab552~mv2.png"
  ],
  // names that probably belong to the painted body
  bodyMaterialNameIncludes:["body","paint","carpaint","car_paint","vehicle_body"]
};
/* ================================= */

const buildTag = document.getElementById('buildTag');
const errorTag = document.getElementById('errorTag');
function showError(msg){ errorTag.style.display='block'; errorTag.textContent = msg; console.error(msg); }

/* ---------- dynamic script loaders ---------- */
function loadScript(url){return new Promise((res,rej)=>{const s=document.createElement('script');s.src=url;s.onload=res;s.onerror=()=>rej(new Error('load '+url));document.head.appendChild(s);});}
async function ensure(urls, test){
  if (test()) return;
  for (const u of urls){ try{ await loadScript(u); if (test()) return; }catch(e){} }
  throw new Error('failed to load '+urls[0]);
}
async function ensureOrbitControls(){
  await ensure([
    'https://cdn.jsdelivr.net/npm/three@0.159.0/examples/js/controls/OrbitControls.js',
    'https://unpkg.com/three@0.159.0/examples/js/controls/OrbitControls.js',
    'https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js'
  ], ()=> (window.THREE && THREE.OrbitControls) || window.OrbitControls );
}
async function ensureGLTFLoader(){
  await ensure([
    'https://cdn.jsdelivr.net/npm/three@0.159.0/examples/js/loaders/GLTFLoader.js',
    'https://unpkg.com/three@0.159.0/examples/js/loaders/GLTFLoader.js',
    'https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js'
  ], ()=> (window.THREE && THREE.GLTFLoader) || window.GLTFLoader );
}
async function ensureDRACO(){
  await ensure([
    'https://cdn.jsdelivr.net/npm/three@0.159.0/examples/js/loaders/DRACOLoader.js',
    'https://unpkg.com/three@0.159.0/examples/js/loaders/DRACOLoader.js'
  ], ()=> (window.THREE && THREE.DRACOLoader) || window.DRACOLoader ).catch(()=>{});
}
async function ensureDecalGeometry(){
  await ensure([
    'https://cdn.jsdelivr.net/npm/three@0.159.0/examples/js/geometries/DecalGeometry.js',
    'https://unpkg.com/three@0.159.0/examples/js/geometries/DecalGeometry.js',
    'https://unpkg.com/three@0.128.0/examples/js/geometries/DecalGeometry.js'
  ], ()=> THREE.DecalGeometry );
}
/* ------------------------------------------- */

let scene,camera,renderer,controls,raycaster,mouse;
let currentVehicle=null,decalTextureURL=null;
let decals=[], draggingDecal=null, dragOffset=null;
let vehicleMaxSize=5; // updated after each load

// >>> ADDED: stricter filter to avoid coloring tires/rims/lights/glass
const NOT_BODY_KEYWORDS = [
  'tire','tyre','wheel','rim','hub','brake','caliper','disc','glass','window','windshield',
  'head','tail','light','indicator','turn','lamp','led','badge','emblem','grille','chrome',
  'rubber','mirror','trim','seat','interior','license','plate','exhaust','rim_f','rim_r'
];
function isBodyMaterial(mat, meshName=''){
  const name = ((mat?.name)||'') + ' ' + (meshName||'');
  const s = name.toLowerCase();
  if (NOT_BODY_KEYWORDS.some(k=>s.includes(k))) return false;
  // skip obvious light materials with strong emissive
  if (mat && mat.emissive && (mat.emissive.r>0.05||mat.emissive.g>0.05||mat.emissive.b>0.05)) return false;
  // only PBR paint-like mats
  return mat && (mat.isMeshStandardMaterial || mat.isMeshPhysicalMaterial);
}

// Start
window.onload = () => { (async ()=>{
  try { await init(); animate(); }
  catch (e) { showError('Init error: ' + e.message); }
})(); };

async function init(){
  const canvas=document.getElementById("c");
  scene=new THREE.Scene();
  scene.background=new THREE.Color(0xe9eaee);

  camera=new THREE.PerspectiveCamera(50,window.innerWidth/window.innerHeight,0.1,2000);
  camera.position.set(0, 2, 8);

  renderer=new THREE.WebGLRenderer({canvas,antialias:true});
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth-340,window.innerHeight);
  if (renderer.outputColorSpace) renderer.outputColorSpace = THREE.SRGBColorSpace;

  const hemi=new THREE.HemisphereLight(0xffffff,0xcfd6df,0.9); scene.add(hemi);
  const dir=new THREE.DirectionalLight(0xffffff,0.8); dir.position.set(5,10,7); scene.add(dir);

  await ensureOrbitControls().catch(()=>{});
  let OC=null;
  if (window.THREE && typeof THREE.OrbitControls==='function') OC=THREE.OrbitControls;
  else if (typeof window.OrbitControls==='function') OC=window.OrbitControls;
  if (OC){
    controls=new OC(camera,renderer.domElement);
    controls.enableDamping=true;
  }else{
    // simple fallback camera
    let isDown=false,lastX=0,lastY=0,theta=0,phi=0,dist=8,target=new THREE.Vector3(0,0,0);
    function updateCam(){
      const x=target.x+dist*Math.cos(phi)*Math.sin(theta);
      const y=target.y+dist*Math.sin(phi);
      const z=target.z+dist*Math.cos(phi)*Math.cos(theta);
      camera.position.set(x,y,z); camera.lookAt(target);
    }
    updateCam();
    renderer.domElement.addEventListener('mousedown',e=>{isDown=true;lastX=e.clientX;lastY=e.clientY;});
    window.addEventListener('mouseup',()=>{isDown=false;});
    window.addEventListener('mousemove',e=>{
      if(!isDown)return;
      const dx=(e.clientX-lastX)/200, dy=(e.clientY-lastY)/200;
      theta-=dx; phi+=dy; phi=Math.max(-1.2,Math.min(1.2,phi));
      lastX=e.clientX; lastY=e.clientY; updateCam();
    });
    renderer.domElement.addEventListener('wheel',e=>{
      dist*= (e.deltaY>0?1.1:0.9); dist=Math.max(2,30,dist); updateCam();
    },{passive:true});
    controls={target:new THREE.Vector3(), update(){}};
    showError('OrbitControls failed to load; using fallback camera (drag to rotate, wheel to zoom).');
  }

  const ground=new THREE.Mesh(
    new THREE.PlaneGeometry(50,50),
    new THREE.MeshStandardMaterial({color:0xdfe3ea,roughness:1})
  );
  ground.rotation.x=-Math.PI/2; ground.position.y=0; scene.add(ground);

  raycaster=new THREE.Raycaster();
  mouse=new THREE.Vector2();

  setupUI();

  window.addEventListener("resize",onResize);
  renderer.domElement.addEventListener("pointerdown",onPointerDown);
  renderer.domElement.addEventListener("pointermove",onPointerMove);
  renderer.domElement.addEventListener("pointerup",()=>draggingDecal=null);

  buildTag.textContent = `Build r14 • vehicles: ${CONFIG.vehicles.length} • decals: ${CONFIG.decals.length}`;
}

/* ===== Fit camera ===== */
function fitCameraToObject(obj, offset=1.6){
  const box = new THREE.Box3().setFromObject(obj);
  const size = box.getSize(new THREE.Vector3());
  const center = box.getCenter(new THREE.Vector3());
  vehicleMaxSize = Math.max(size.x, size.y, size.z);

  const fitHeight = vehicleMaxSize / (2 * Math.tan(THREE.MathUtils.degToRad(camera.fov) / 2));
  const fitWidth  = fitHeight / camera.aspect;
  const distance  = offset * Math.max(fitHeight, fitWidth);

  const currentTarget = (controls && controls.target) ? controls.target.clone() : new THREE.Vector3();
  const dir = camera.position.clone().sub(currentTarget).normalize();

  camera.position.copy(center.clone().add(dir.multiplyScalar(distance)));
  if (controls && controls.target) {
    controls.target.copy(center);
    controls.minDistance = distance * 0.4;
    controls.maxDistance = distance * 5;
    controls.update();
  } else {
    camera.lookAt(center);
  }
  camera.updateProjectionMatrix();
}

/* ===== UI ===== */
function setupUI(){
  const vs=document.getElementById("vehicleSelect");
  vs.innerHTML="";
  CONFIG.vehicles.forEach(v=>{
    const opt=document.createElement("option");
    opt.value=v.url; opt.textContent=v.name; vs.appendChild(opt);
  });
  vs.addEventListener("change",()=>loadVehicle(vs.value));
  if(CONFIG.vehicles.length){
    loadVehicle(CONFIG.vehicles[0].url);
    vs.value=CONFIG.vehicles[0].url;
  }

  const gallery=document.getElementById("decalGallery");
  gallery.innerHTML="";
  let lastBtn=null;
  CONFIG.decals.forEach(url=>{
    const btn=document.createElement("button");
    const img=document.createElement("img");
    img.src=url; btn.appendChild(img);
    btn.addEventListener("click",()=>{
      decalTextureURL=url;
      if(lastBtn) lastBtn.classList.remove('selectedDecal');
      btn.classList.add('selectedDecal'); lastBtn=btn;
    });
    gallery.appendChild(btn);
  });

  document.getElementById("decalUpload").addEventListener("change",e=>{
    const file=e.target.files[0]; if(!file)return;
    const reader=new FileReader();
    reader.onload=ev=>{
      decalTextureURL=ev.target.result;
      document.querySelectorAll('#decalGallery .selectedDecal').forEach(b=>b.classList.remove('selectedDecal'));
    };
    reader.readAsDataURL(file);
  });

  document.getElementById("applyColorBtn").addEventListener("click",()=>{
    applyBodyColor(document.getElementById("bodyColor").value);
  });
}

function onResize(){
  const w=window.innerWidth-340,h=window.innerHeight;
  camera.aspect=w/h; camera.updateProjectionMatrix();
  renderer.setSize(w,h);
}

/* ===== Load/position vehicle (fix ‘half under floor’) ===== */
async function loadVehicle(url){
  if(currentVehicle) scene.remove(currentVehicle);
  currentVehicle=null;

  try{
    await ensureGLTFLoader(); await ensureDRACO();
    const GLTF=(window.THREE&&THREE.GLTFLoader)||window.GLTFLoader;
    const loader=new GLTF();
    const DRACO=(window.THREE&&THREE.DRACOLoader)||window.DRACOLoader;
    if(DRACO){
      const dl=new DRACO();
      dl.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
      if (loader.setDRACOLoader) loader.setDRACOLoader(dl);
    }

    loader.load(url,(gltf)=>{
      currentVehicle=gltf.scene;

      // >>> ADDED: ensure meshes accept raycast & proper depth (helps decals)
      currentVehicle.traverse(o=>{
        if(o.isMesh){
          o.castShadow = true;
          o.receiveShadow = true;
          if (o.material) {
            const mats = Array.isArray(o.material) ? o.material : [o.material];
            mats.forEach(m=>{ if(m) { m.depthWrite = true; m.depthTest = true; } });
          }
        }
      });

      scene.add(currentVehicle);

      // normalize to consistent size
      const box0=new THREE.Box3().setFromObject(currentVehicle);
      const size0=new THREE.Vector3(); box0.getSize(size0);
      const center0=new THREE.Vector3(); box0.getCenter(center0);
      currentVehicle.position.sub(center0);

      const scale=4.5/Math.max(size0.x, size0.z || 1);
      currentVehicle.scale.setScalar(scale);

      // >>> ADDED: slight additional “stretch/size bump”
      currentVehicle.scale.multiplyScalar(1.18); // subtle scale-up
      currentVehicle.position.z -= 0.35;        // bring a bit closer to camera

      // after scaling, align lowest point to y=0 (so wheels sit on ground)
      const box1=new THREE.Box3().setFromObject(currentVehicle);
      currentVehicle.position.y -= box1.min.y;

      // >>> CHANGED: slightly closer framing
      fitCameraToObject(currentVehicle, 1.45);

    },undefined,err=>{
      showError("Could not load vehicle model. Check the URL.");
    });
  }catch(e){
    showError('GLTFLoader missing; cannot load models.');
  }
}

/* ===== Paint body color (works even if the mesh had a texture) ===== */
function applyBodyColor(hex){
  if(!currentVehicle)return;

  const hints=CONFIG.bodyMaterialNameIncludes;
  const hexColor=new THREE.Color(hex);

  currentVehicle.traverse(obj=>{
    if(!obj.isMesh || !obj.material) return;

    const mats = Array.isArray(obj.material)?obj.material:[obj.material];
    mats.forEach((m,i)=>{
      if(!m) return;
      const name=(m.name||'') + ' ' + (obj.name||'');
      const nameLC=name.toLowerCase();

      // >>> CHANGED: only paint likely body materials
      const looksLikeBodyByName = hints.some(h=> nameLC.includes(h));
      const passFilter = looksLikeBodyByName || isBodyMaterial(m, obj.name);

      if(passFilter){
        const clone = m.clone();

        // keep metallic/roughness but set color; remove base map if present
        clone.color = hexColor.clone();
        clone.map = null;

        // keep clearcoat if present; otherwise set sensible defaults
        if (clone.metalness === undefined) clone.metalness = 0.1;
        if (clone.roughness === undefined) clone.roughness = 0.4;

        clone.needsUpdate = true;
        if(Array.isArray(obj.material)) obj.material[i]=clone; else obj.material=clone;
      }
    });
  });
}

/* ===== Interaction (place & drag decals) ===== */
renderer?.domElement?.addEventListener;
async function onPointerDown(event){
  mouse.x=(event.offsetX/renderer.domElement.clientWidth)*2-1;
  mouse.y=-(event.offsetY/renderer.domElement.clientHeight)*2+1;
  raycaster.setFromCamera(mouse,camera);

  // grab existing decal?
  const decalHits=raycaster.intersectObjects(decals);
  if(decalHits.length){
    draggingDecal=decalHits[0].object;
    dragOffset=draggingDecal.position.clone().sub(decalHits[0].point);
    return;
  }

  // place a new one
  if(!decalTextureURL||!currentVehicle)return;

  try{ await ensureDecalGeometry(); }catch(e){ showError('DecalGeometry missing; decals disabled.'); return; }

  const hits=raycaster.intersectObject(currentVehicle,true);
  if(hits.length){
    const hit=hits[0];
    addDecalOnHit(hit, decalTextureURL);
  }
}

function onPointerMove(event){
  if(!draggingDecal)return;
  mouse.x=(event.offsetX/renderer.domElement.clientWidth)*2-1;
  mouse.y=-(event.offsetY/renderer.domElement.clientHeight)*2+1;
  raycaster.setFromCamera(mouse,camera);
  const hits=raycaster.intersectObject(currentVehicle,true);
  if(hits.length){
    const hit=hits[0];
    draggingDecal.position.copy(hit.point.add(dragOffset||new THREE.Vector3()));
  }
}

/* ---- Decal placement: robust, visible, CORS-safe ---- */
function addDecalOnHit(hit, texURL){
  const targetMesh = hit.object;
  const position   = hit.point.clone();

  // world-space normal
  const normal = hit.face.normal.clone();
  normal.transformDirection(new THREE.Matrix3().getNormalMatrix(targetMesh.matrixWorld));

  // orientation so +Z faces out
  const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), normal.clone().normalize());
  const orientation = new THREE.Euler().setFromQuaternion(quat);

  // size relative to car size (so it’s never microscopic)
  const s = Math.max(0.2, vehicleMaxSize * 0.12); // ~12% of car length
  const size = new THREE.Vector3(s, s, 0.01);

  const loader = new THREE.TextureLoader();
  loader.setCrossOrigin('anonymous');                 // >>> ADDED (helps CDN/bucket textures)
  const tex = loader.load(texURL);
  if (renderer.outputColorSpace) tex.colorSpace = THREE.SRGBColorSpace;
  tex.anisotropy = 8;

  const mat = new THREE.MeshStandardMaterial({
    map: tex,
    color: 0xffffff,
    transparent: true,
    opacity: 1,
    alphaTest: 0.5,               // >>> ADDED (ensures PNG cutouts render)
    depthTest: true,
    depthWrite: false,            // >>> ADDED (prevents overwriting depth buffer)
    polygonOffset: true,
    polygonOffsetFactor: -4,      // >>> ADDED (reduces z-fighting)
    side: THREE.DoubleSide
  });

  const geo  = new THREE.DecalGeometry(targetMesh, position, orientation, size);
  const mesh = new THREE.Mesh(geo, mat);
  mesh.renderOrder = 10;          // >>> ADDED (draw on top of body)
  scene.add(mesh);
  decals.push(mesh);
}

/* ===== Loop ===== */
function animate(){
  requestAnimationFrame(animate);
  renderer.render(scene,camera);
}
</script>
</body>
</html>
