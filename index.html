<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>C3C – Interactive 3D Customizer</title>
<style>
*{box-sizing:border-box;margin:0;padding:0}
html,body{width:100%;height:100%;background:#e9eaee;color:#111;font-family:sans-serif}
#app{display:flex;height:100vh}
#ui{width:340px;max-width:340px;min-width:300px;padding:10px;background:#f4f5f7;overflow:auto;border-right:1px solid #dde0e6}
#canvasWrap{flex:1;position:relative;background:#e9eaee}
#c{display:block;width:100%;height:100%}
.row{margin-bottom:10px;display:flex;flex-wrap:wrap;gap:6px;align-items:center}
label{font-size:14px}
input,select,button{background:#fff;color:#111;border:1px solid #cfd6df;padding:6px;border-radius:4px}
button{cursor:pointer}
#decalGallery{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-top:6px}
#decalGallery button{background:#fff;border:1px solid #cfd6df;border-radius:6px;padding:0;overflow:hidden;height:72px}
#decalGallery img{width:100%;height:100%;object-fit:contain;background:#fff}
.note{font-size:12px;opacity:.75;color:#333}
#buildTag{position:fixed;left:8px;top:6px;opacity:.85;font:12px/1 monospace;z-index:10;color:#333}
#errorTag{position:fixed;right:8px;top:6px;background:#b00020;color:#fff;padding:6px 8px;border-radius:6px;display:none;max-width:70ch;font:12px/1.2 monospace;z-index:10}
.selectedDecal{outline:2px solid #4caf50}
#dropHint{position:absolute;inset:auto 12px 12px 12px;padding:8px 10px;border-radius:8px;background:rgba(255,255,255,0.9);font:12px/1.2 system-ui;color:#333;display:none;pointer-events:none}
</style>

<!-- Pin three r159 -->
<script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js?v=159" crossorigin="anonymous"></script>
</head>
<body>
<div id="buildTag">initializing…</div>
<div id="errorTag"></div>

<div id="app">
  <div id="ui">
    <div class="row">
      <label for="vehicleSelect">Vehicle:</label>
      <select id="vehicleSelect"></select>
    </div>
    <div class="row">
      <label for="bodyColor">Body Color:</label>
      <input type="color" id="bodyColor" value="#1c4cff">
      <button id="applyColorBtn">Apply</button>
    </div>
    <div class="row">
      <label>Decals (click or drag onto vehicle):</label>
      <div id="decalGallery"></div>
    </div>
    <div class="row">
      <label for="decalUpload">Upload your decal:</label>
      <input type="file" id="decalUpload" accept="image/*">
    </div>
    <div class="note">Click a decal, then click the vehicle body to place — or drag a decal from the gallery onto the car. After placing, drag decals to move them.</div>
  </div>
  <div id="canvasWrap"><canvas id="c"></canvas><div id="dropHint">Drop to place decal</div></div>
</div>

<script>
/* ===== CONFIG ===== */
const CONFIG = {
  vehicles: [
    { name:"Durango",  url:"https://static.wixstatic.com/3d/96cc34_c0072ed49aab4a86b58e8856adc9e80d.glb" },
    { name:"Explorer", url:"https://static.wixstatic.com/3d/96cc34_26fca487bc13404a965465fa0894bb31.glb" },
    { name:"Mercedes (Ambulance)", url:"https://static.wixstatic.com/3d/96cc34_9fce89e6202d462eb9efb22164250445.glb" },
    { name:"Tahoe",    url:"https://static.wixstatic.com/3d/96cc34_3402bc1505d84d25a03dfdd63dc98cb5.glb" }
  ],
  decals: [
    "https://static.wixstatic.com/media/96cc34_45d6c4ae8e19430bb0f853a313752d6e~mv2.png",
    "https://static.wixstatic.com/media/96cc34_3b6ee3d5d22046269faa3f0abfa5be4b~mv2.png",
    "https://static.wixstatic.com/media/96cc34_02a7f12787d94a338b71cbc076c131ef~mv2.png",
    "https://static.wixstatic.com/media/96cc34_d3aae6ee15ea45b99d31d20148e73144~mv2.png",
    "https://static.wixstatic.com/media/96cc34_738b9da24fef4290b6e3ae9996a8e722~mv2.png",
    "https://static.wixstatic.com/media/96cc34_cbb180b170324ffa8803f487f2c588e3~mv2.png",
    "https://static.wixstatic.com/media/96cc34_60097843bb9a4db39d54929f138ab552~mv2.png"
  ],
  bodyMaterialNameIncludes:["body","paint","carpaint","car_paint","vehicle_body","shell","panel","door","hood","fender","quarter","bumper"]
};

const buildTag = document.getElementById('buildTag');
const errorTag = document.getElementById('errorTag');
function showError(msg){ errorTag.style.display='block'; errorTag.textContent = msg; console.error(msg); }
function updateBuildTag(){
  buildTag.textContent = `Build r${(window.THREE&&THREE.REVISION)||'??'} • vehicles: ${CONFIG.vehicles.length} • decals: ${CONFIG.decals.length}`;
}

/* ---------- dynamic script loaders (non-throwing controls) ---------- */
function loadScript(url){return new Promise((res,rej)=>{const s=document.createElement('script');s.src=url;s.onload=res;s.onerror=()=>rej(new Error('load '+url));document.head.appendChild(s);});}
async function ensure(urls, test){
  if (test()) return true;
  for (const u of urls){ try{ await loadScript(u); if (test()) return true; }catch(e){} }
  return false;
}
async function ensureOrbitControls(){
  let ok = await ensure([
    'https://cdn.jsdelivr.net/npm/three@0.159.0/examples/js/controls/OrbitControls.js',
    'https://unpkg.com/three@0.159.0/examples/js/controls/OrbitControls.js'
  ], ()=> (window.THREE && THREE.OrbitControls) || window.OrbitControls );
  if (ok) return true;
  try {
    const { OrbitControls: OC } = await import('https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/controls/OrbitControls.js');
    window.OrbitControls = function(camera, dom){ return new OC(camera, dom); };
    return true;
  } catch(e){
    console.warn('OrbitControls unavailable; falling back to manual camera.');
    return false; // DO NOT throw
  }
}
async function ensureGLTFLoader(){
  const ok = await ensure([
    'https://cdn.jsdelivr.net/npm/three@0.159.0/examples/js/loaders/GLTFLoader.js',
    'https://unpkg.com/three@0.159.0/examples/js/loaders/GLTFLoader.js'
  ], ()=> (window.THREE && THREE.GLTFLoader) || window.GLTFLoader );
  if (ok) return true;
  try {
    const mod = await import('https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/loaders/GLTFLoader.js');
    window.GLTFLoader = mod.GLTFLoader || mod.default;
    window.GLTF = window.GLTFLoader;
    return true;
  } catch(e){
    return false; // let loadVehicle show a friendly error
  }
}
async function ensureDRACO(){
  const ok = await ensure([
    'https://cdn.jsdelivr.net/npm/three@0.159.0/examples/js/loaders/DRACOLoader.js',
    'https://unpkg.com/three@0.159.0/examples/js/loaders/DRACOLoader.js'
  ], ()=> (window.THREE && THREE.DRACOLoader) || window.DRACOLoader );
  if (ok) return true;
  try {
    const mod = await import('https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/loaders/DRACOLoader.js');
    window.DRACOLoader = mod.DRACOLoader || mod.default;
  } catch(e){ console.warn('DRACO optional and unavailable.'); }
  return true;
}
async function ensureDecalGeometry(){
  let ok = await ensure([
    'https://cdn.jsdelivr.net/npm/three@0.159.0/examples/js/geometries/DecalGeometry.js',
    'https://unpkg.com/three@0.159.0/examples/js/geometries/DecalGeometry.js'
  ], ()=> THREE.DecalGeometry );
  if (ok) return true;
  try {
    const mod = await import('https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/geometries/DecalGeometry.js');
    THREE.DecalGeometry = mod.DecalGeometry || mod.default;
    return true;
  } catch(e){ return false; }
}

/* ------------------------------------------- */
let scene,camera,renderer,controls,raycaster,mouse;
let currentVehicle=null,decalTextureURL=null;
let decals=[], draggingDecal=null, dragOffset=null;
let vehicleMaxSize=5;
let decalTargets = [];
let paintableMeshes = [];
let awaitingPlacement = false;

const NOT_BODY_KEYWORDS = [
  'tire','tyre','wheel','rim','hub','lug','brake','caliper','disc',
  'glass','window','windshield','windscreen',
  'head','tail','light','indicator','turn','lamp','led','fog','reverse','brakelight',
  'badge','emblem','grille','chrome','rubber','mirror','trim','antenna',
  'seat','interior','license','plate','exhaust','chassis','underbody','engine'
];

function isBodyMaterial(mat, meshName=''){
  const s = (((mat?.name)||'') + ' ' + (meshName||'')).toLowerCase();
  if (NOT_BODY_KEYWORDS.some(k=>s.includes(k))) return false;
  if (mat?.transparent || mat?.opacity < 0.98 || mat?.transmission > 0) return false;
  if (mat?.emissive && (mat.emissive.r>0.05||mat.emissive.g>0.05||mat.emissive.b>0.05)) return false;
  return mat && (mat.isMeshStandardMaterial || mat.isMeshPhysicalMaterial);
}
function collectBodyMeshes(root){
  const body=[]; root.traverse(o=>{
    if(!o.isMesh||!o.material||!o.geometry) return;
    const mats = Array.isArray(o.material)?o.material:[o.material];
    const pass = mats.some(m=>isBodyMaterial(m,o.name));
    if(!pass) return;
    const a=o.geometry.attributes?.position; const tri = a?Math.floor(a.count/3):0;
    if(tri<150) return;
    body.push(o);
  });
  if(body.length===0){
    root.traverse(o=>{
      if(!o.isMesh||!o.material||!o.geometry) return;
      const mats = Array.isArray(o.material)?o.material:[o.material];
      const s = (((mats[0]?.name)||'')+' '+(o.name||'')).toLowerCase();
      const a=o.geometry.attributes?.position; const tri=a?Math.floor(a.count/3):0;
      const bad = NOT_BODY_KEYWORDS.some(k=>s.includes(k)) || mats.some(m=>m?.transparent||m?.opacity<0.98||m?.transmission>0);
      if(!bad && tri>=300) body.push(o);
    });
  }
  return body;
}

// Start
window.onload = () => { (async ()=>{
  try { await init(); animate(); }
  catch (e) { showError('Init error: ' + e.message); }
})(); };

async function init(){
  const canvas=document.getElementById("c");
  scene=new THREE.Scene();
  scene.background=new THREE.Color(0xe9eaee);

  camera=new THREE.PerspectiveCamera(50,window.innerWidth/window.innerHeight,0.1,2000);
  camera.position.set(0, 2, 6.0);

  renderer=new THREE.WebGLRenderer({canvas,antialias:true});
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth-340,window.innerHeight);
  if (renderer.outputColorSpace) renderer.outputColorSpace = THREE.SRGBColorSpace;

  const hemi=new THREE.HemisphereLight(0xffffff,0xcfd6df,0.95); scene.add(hemi);
  const dir=new THREE.DirectionalLight(0xffffff,0.9); dir.position.set(5,10,7); scene.add(dir);

  await ensureOrbitControls(); // never throws
  let OC=null;
  if (window.THREE && typeof THREE.OrbitControls==='function') OC=THREE.OrbitControls;
  else if (typeof window.OrbitControls==='function') OC=window.OrbitControls;
  if (OC){
    controls=new OC(camera,renderer.domElement);
    controls.enableDamping=true;
  }else{
    // simple fallback camera
    let isDown=false,lastX=0,lastY=0,theta=0,phi=0,dist=6.0,target=new THREE.Vector3(0,0,0);
    function updateCam(){
      const x=target.x+dist*Math.cos(phi)*Math.sin(theta);
      const y=target.y+dist*Math.sin(phi);
      const z=target.z+dist*Math.cos(phi)*Math.cos(theta);
      camera.position.set(x,y,z); camera.lookAt(target);
    }
    updateCam();
    renderer.domElement.addEventListener('mousedown',e=>{isDown=true;lastX=e.clientX;lastY=e.clientY;});
    window.addEventListener('mouseup',()=>{isDown=false;});
    window.addEventListener('mousemove',e=>{
      if(!isDown)return;
      const dx=(e.clientX-lastX)/200, dy=(e.clientY-lastY)/200;
      theta-=dx; phi+=dy; phi=Math.max(-1.2,Math.min(1.2,phi));
      lastX=e.clientX; lastY=e.clientY; updateCam();
    });
    renderer.domElement.addEventListener('wheel',e=>{
      dist*= (e.deltaY>0?1.1:0.9); dist=Math.max(2,30,dist); updateCam();
    },{passive:true});
    controls={target:new THREE.Vector3(), update(){}};
  }

  const ground=new THREE.Mesh(
    new THREE.PlaneGeometry(50,50),
    new THREE.MeshStandardMaterial({color:0xdfe3ea,roughness:1})
  );
  ground.rotation.x=-Math.PI/2; ground.position.y=0; scene.add(ground);

  raycaster=new THREE.Raycaster();
  mouse=new THREE.Vector2();

  setupUI();
  setupDragAndDrop();

  window.addEventListener("resize",onResize);
  renderer.domElement.addEventListener("pointerdown",onPointerDown);
  renderer.domElement.addEventListener("pointermove",onPointerMove);
  renderer.domElement.addEventListener("pointerup",()=>draggingDecal=null);

  updateBuildTag();
}

function fitCameraToObject(obj, offset=1.06){
  const box = new THREE.Box3().setFromObject(obj);
  const size = box.getSize(new THREE.Vector3());
  const center = box.getCenter(new THREE.Vector3());
  vehicleMaxSize = Math.max(size.x, size.y, size.z);

  const fitH = vehicleMaxSize / (2 * Math.tan(THREE.MathUtils.degToRad(camera.fov) / 2));
  const fitW = fitH / camera.aspect;
  const distance = offset * Math.max(fitH, fitW);

  const currentTarget = (controls && controls.target) ? controls.target.clone() : new THREE.Vector3();
  const dir = camera.position.clone().sub(currentTarget).normalize();

  camera.position.copy(center.clone().add(dir.multiplyScalar(distance)));
  if (controls && controls.target) {
    controls.target.copy(center);
    controls.minDistance = Math.max(0.1, distance * 0.35);
    controls.maxDistance = distance * 4;
    controls.update();
  } else {
    camera.lookAt(center);
  }
  camera.updateProjectionMatrix();
}

/* ===== UI ===== */
function setupUI(){
  const vs=document.getElementById("vehicleSelect");
  vs.innerHTML="";
  CONFIG.vehicles.forEach(v=>{
    const opt=document.createElement("option");
    opt.value=v.url; opt.textContent=v.name; vs.appendChild(opt);
  });
  vs.addEventListener("change",()=>loadVehicle(vs.value));
  if(CONFIG.vehicles.length){
    loadVehicle(CONFIG.vehicles[0].url);
    vs.value=CONFIG.vehicles[0].url;
  }

  const gallery=document.getElementById("decalGallery");
  gallery.innerHTML="";
  CONFIG.decals.forEach(url=>{
    const btn=document.createElement("button");
    const img=document.createElement("img");
    img.src=url; img.draggable=true;
    img.dataset.decalUrl = url;
    btn.appendChild(img);
    btn.addEventListener("click",()=>selectDecalURL(url, btn));
    img.addEventListener('dragstart', ev=>{
      ev.dataTransfer.setData('text/uri-list', url);
      ev.dataTransfer.setData('text/plain', url);
      ev.dataTransfer.effectAllowed = 'copy';
    });
    gallery.appendChild(btn);
  });

  document.getElementById("decalUpload").addEventListener("change",e=>{
    const file=e.target.files[0]; if(!file)return;
    const objUrl = URL.createObjectURL(file);
    const gallery=document.getElementById("decalGallery");
    const btn=document.createElement("button");
    const img=document.createElement("img");
    img.src=objUrl; img.draggable=true; img.dataset.decalUrl=objUrl;
    btn.appendChild(img);
    gallery.prepend(btn);
    btn.addEventListener("click",()=>selectDecalURL(objUrl, btn));
    img.addEventListener('dragstart', ev=>{
      ev.dataTransfer.setData('text/uri-list', objUrl);
      ev.dataTransfer.setData('text/plain', objUrl);
      ev.dataTransfer.effectAllowed = 'copy';
    });
    selectDecalURL(objUrl, btn);
    awaitingPlacement = true;
    showDropHint(true, "Click the vehicle to place your uploaded decal");
  });

  document.getElementById("applyColorBtn").addEventListener("click",()=>{
    applyBodyColor(document.getElementById("bodyColor").value);
  });
}

function selectDecalURL(url, button){
  decalTextureURL = url;
  document.querySelectorAll('#decalGallery .selectedDecal').forEach(b=>b.classList.remove('selectedDecal'));
  if (button) button.classList.add('selectedDecal');
  awaitingPlacement = true;
  showDropHint(true, "Click the vehicle body to place the decal");
}

function onResize(){
  const w=window.innerWidth-340,h=window.innerHeight;
  camera.aspect=w/h; camera.updateProjectionMatrix();
  renderer.setSize(w,h);
}

/* ===== Load/position vehicle ===== */
async function loadVehicle(url){
  // clear decals
  decals.forEach(d => { d.parent?.remove(d); d.geometry?.dispose(); if (d.material?.map) d.material.map.dispose(); d.material?.dispose(); });
  decals = [];

  if(currentVehicle) scene.remove(currentVehicle);
  currentVehicle=null;
  paintableMeshes = [];
  decalTargets = [];

  const haveGLTF = await ensureGLTFLoader(); await ensureDRACO();
  if (!haveGLTF) { showError('GLTFLoader missing; cannot load models.'); return; }

  const GLTF=(window.THREE&&THREE.GLTFLoader)||window.GLTFLoader||window.GLTF;
  const loader=new GLTF();

  const DRACO=(window.THREE&&THREE.DRACOLoader)||window.DRACOLoader;
  if(DRACO && loader.setDRACOLoader){
    const dl=new DRACO();
    dl.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
    loader.setDRACOLoader(dl);
  }

  loader.load(url,(gltf)=>{
    currentVehicle=gltf.scene;

    currentVehicle.traverse(o=>{
      if(o.isMesh){
        o.castShadow = true;
        o.receiveShadow = true;
        if (o.material) {
          const mats = Array.isArray(o.material) ? o.material : [o.material];
          mats.forEach(m=>{ if(m) { m.depthWrite = true; m.depthTest = true; } });
        }
      }
    });

    scene.add(currentVehicle);

    // normalize & center
    const box0=new THREE.Box3().setFromObject(currentVehicle);
    const size0=new THREE.Vector3(); box0.getSize(size0);
    const center0=new THREE.Vector3(); box0.getCenter(center0);
    currentVehicle.position.sub(center0);

    const scale=4.5/Math.max(size0.x, size0.z || 1);
    currentVehicle.scale.setScalar(scale);

    currentVehicle.scale.multiplyScalar(1.24);
    currentVehicle.position.z -= 0.6;

    const box1=new THREE.Box3().setFromObject(currentVehicle);
    currentVehicle.position.y -= box1.min.y;

    // targets
    paintableMeshes = collectBodyMeshes(currentVehicle);
    decalTargets = paintableMeshes.slice();
    if (decalTargets.length === 0) {
      currentVehicle.traverse(o=>{
        if(!o.isMesh || !o.material) return;
        const mats = Array.isArray(o.material)?o.material:[o.material];
        const bad = mats.some(m => m?.transparent || m?.opacity<0.98 || m?.transmission>0);
        const name = (((mats[0]?.name)||'') + ' ' + (o.name||'')).toLowerCase();
        if (!bad && !NOT_BODY_KEYWORDS.some(k=>name.includes(k))) decalTargets.push(o);
      });
    }

    fitCameraToObject(currentVehicle, 1.06);
    updateBuildTag();
  },undefined,err=>{
    showError("Could not load vehicle model. Check the URL.");
  });
}

/* ===== Body-only Paint ===== */
function applyBodyColor(hex){
  if(!currentVehicle) return;
  const hexColor = new THREE.Color(hex);
  paintableMeshes.forEach(obj=>{
    const mats = Array.isArray(obj.material)?obj.material:[obj.material];
    mats.forEach((m,i)=>{
      if(!m) return;
      const clone = m.clone();
      clone.color = hexColor.clone();
      clone.map   = null;
      clone.transparent = false;
      clone.transmission = 0;
      if (clone.metalness === undefined) clone.metalness = 0.1;
      if (clone.roughness === undefined) clone.roughness = 0.4;
      clone.needsUpdate = true;
      if(Array.isArray(obj.material)) obj.material[i] = clone; else obj.material = clone;
    });
  });
}

/* ===== Interaction (click place & drag decals) ===== */
renderer?.domElement?.addEventListener;
async function onPointerDown(event){
  mouse.x=(event.offsetX/renderer.domElement.clientWidth)*2-1;
  mouse.y=-(event.offsetY/renderer.domElement.clientHeight)*2+1;
  raycaster.setFromCamera(mouse,camera);

  const decalHits=raycaster.intersectObjects(decals, true);
  if(decalHits.length){
    draggingDecal=decalHits[0].object;
    dragOffset=draggingDecal.position.clone().sub(decalHits[0].point);
    showDropHint(false);
    return;
  }

  if(!decalTextureURL||!currentVehicle) { showDropHint(false); return; }

  const ok = await ensureDecalGeometry();
  if(!ok){ showError('DecalGeometry missing; decals disabled.'); return; }

  currentVehicle.updateMatrixWorld(true);

  const targetSet = (decalTargets.length ? decalTargets : [currentVehicle]);
  const hits=raycaster.intersectObjects(targetSet, true);
  if(hits.length){
    debugHitDot(hits[0].point);
    addDecalOnHit(hits[0], decalTextureURL);
    awaitingPlacement = false;
    showDropHint(false);
  }
}

function onPointerMove(event){
  if(!draggingDecal) {
    if (awaitingPlacement) showDropHint(true, "Click the vehicle body to place the decal");
    return;
  }
  mouse.x=(event.offsetX/renderer.domElement.clientWidth)*2-1;
  mouse.y=-(event.offsetY/renderer.domElement.clientHeight)*2+1;
  raycaster.setFromCamera(mouse,camera);

  currentVehicle.updateMatrixWorld(true);

  const targetSet = (decalTargets.length ? decalTargets : [currentVehicle]);
  const hits=raycaster.intersectObjects(targetSet, true);
  if(hits.length){
    draggingDecal.position.copy(hits[0].point.add(dragOffset || new THREE.Vector3()));
  }
}

/* ---- Decal placement ---- */
function addDecalOnHit(hit, texURL){
  const targetMesh = hit.object;
  const position   = hit.point.clone();

  const normal = hit.face?.normal?.clone() || new THREE.Vector3(0,0,1);
  normal.transformDirection(new THREE.Matrix3().getNormalMatrix(targetMesh.matrixWorld)).normalize();

  const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), normal);
  const orientation = new THREE.Euler().setFromQuaternion(quat);

  const w = Math.max(0.35, vehicleMaxSize * 0.20);
  const h = w;
  const d = Math.max(0.08, vehicleMaxSize * 0.35);

  if (!THREE.DecalGeometry) { showError('DecalGeometry not available.'); return; }
  const geo  = new THREE.DecalGeometry(targetMesh, position, orientation, new THREE.Vector3(w,h,d));
  if (!geo || !geo.attributes || !geo.attributes.position || geo.attributes.position.count === 0) {
    console.warn('DecalGeometry produced empty geometry (skipping).');
    return;
  }

  const placeholderMat = new THREE.MeshBasicMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 0.85,
    depthTest: true,
    depthWrite: false,
    polygonOffset: true,
    polygonOffsetFactor: -10,
    side: THREE.DoubleSide
  });
  const mesh = new THREE.Mesh(geo, placeholderMat);
  mesh.renderOrder = 10;
  scene.add(mesh);
  decals.push(mesh);

  const loader = new THREE.TextureLoader();
  loader.setCrossOrigin('anonymous');
  loader.load(
    texURL,
    (tex)=>{
      if (renderer.outputColorSpace) tex.colorSpace = THREE.SRGBColorSpace;
      tex.anisotropy = 8;
      const mat = new THREE.MeshStandardMaterial({
        map: tex,
        color: 0xffffff,
        transparent: true,
        opacity: 1,
        alphaTest: 0.3,
        depthTest: true,
        depthWrite: false,
        polygonOffset: true,
        polygonOffsetFactor: -10,
        side: THREE.DoubleSide
      });
      mesh.material.dispose();
      mesh.material = mat;
    },
    undefined,
    (err)=> console.warn('Decal texture failed to load:', err)
  );
}

/* ===== Drag-and-drop from gallery onto canvas ===== */
function setupDragAndDrop(){
  const canvas = renderer.domElement;

  ;['dragenter','dragover'].forEach(evName=>{
    canvas.addEventListener(evName, e=>{
      e.preventDefault();
      e.dataTransfer.dropEffect = 'copy';
      showDropHint(true, "Drop to place decal");
    });
  });
  ;['dragleave','dragend','drop'].forEach(evName=>{
    canvas.addEventListener(evName, e=>{
      if (evName !== 'drop') showDropHint(false);
    });
  });

  canvas.addEventListener('drop', async e=>{
    e.preventDefault();
    showDropHint(false);
    if(!currentVehicle) return;

    let url = e.dataTransfer.getData('text/uri-list') || e.dataTransfer.getData('text/plain');
    if (!url && e.dataTransfer.files && e.dataTransfer.files[0]) {
      const file = e.dataTransfer.files[0];
      url = URL.createObjectURL(file);
    }
    if (!url) return;

    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((e.clientX - rect.left)/rect.width) * 2 - 1;
    mouse.y = -((e.clientY - rect.top)/rect.height) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);

    const ok = await ensureDecalGeometry(); if(!ok){ showError('DecalGeometry missing; decals disabled.'); return; }

    currentVehicle.updateMatrixWorld(true);

    const targetSet = (decalTargets.length ? decalTargets : [currentVehicle]);
    const hits = raycaster.intersectObjects(targetSet, true);
    if (!hits.length) return;
    debugHitDot(hits[0].point);
    addDecalOnHit(hits[0], url);
  });
}

function showDropHint(show, text="Drop to place decal"){
  const hint = document.getElementById('dropHint');
  hint.textContent = text;
  hint.style.display = show ? 'block' : 'none';
}

/* === tiny green dot at hit point (auto-fades) === */
function debugHitDot(point){
  const g = new THREE.SphereGeometry(0.02, 12, 12);
  const m = new THREE.MeshBasicMaterial({color:0x00ff66});
  const d = new THREE.Mesh(g,m);
  d.position.copy(point);
  d.renderOrder = 1000;
  scene.add(d);
  let t = 0;
  const fade = ()=> {
    t += 0.02;
    d.material.opacity = Math.max(0, 0.8 - t);
    d.material.transparent = true;
    if (t < 0.8) requestAnimationFrame(fade);
    else { scene.remove(d); g.dispose(); m.dispose(); }
  };
  fade();
}

/* ===== Loop ===== */
function animate(){
  requestAnimationFrame(animate);
  renderer.render(scene,camera);
}
</script>
</body>
</html>
